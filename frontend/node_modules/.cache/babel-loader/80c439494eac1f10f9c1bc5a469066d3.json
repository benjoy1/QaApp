{"ast":null,"code":"const LRU = require('lru-cache');\n\nconst _ = require('lodash');\n\nconst lru_params = ['max', 'maxAge', 'length', 'dispose', 'stale'];\n\nconst deepFreeze = require('./lib/freeze');\n\nconst vfs = require('very-fast-args');\n\nmodule.exports = function (options) {\n  const cache = new LRU(_.pick(options, lru_params));\n  const load = options.load;\n  const hash = options.hash;\n  const bypass = options.bypass;\n  const itemMaxAge = options.itemMaxAge;\n  const freeze = options.freeze;\n  const clone = options.clone;\n  const loading = new Map();\n\n  if (options.disable) {\n    _.extend(load, {\n      del\n    }, options);\n\n    return load;\n  }\n\n  function del() {\n    const key = hash.apply(this, arguments);\n    cache.del(key);\n  }\n\n  const result = function () {\n    const args = vfs.apply(null, arguments);\n    const parameters = args.slice(0, -1);\n    const callback = args.slice(-1).pop();\n    const self = this;\n    var key;\n\n    if (bypass && bypass.apply(self, parameters)) {\n      return load.apply(self, args);\n    }\n\n    if (parameters.length === 0 && !hash) {\n      //the load function only receives callback.\n      key = '_';\n    } else {\n      key = hash.apply(self, parameters);\n    }\n\n    var fromCache = cache.get(key);\n\n    if (fromCache) {\n      if (clone) {\n        return callback.apply(null, [null].concat(fromCache).map(_.cloneDeep));\n      }\n\n      return callback.apply(null, [null].concat(fromCache));\n    }\n\n    if (!loading.get(key)) {\n      loading.set(key, []);\n      load.apply(self, parameters.concat(function (err) {\n        const args = vfs.apply(null, arguments); //we store the result only if the load didn't fail.\n\n        if (!err) {\n          const result = args.slice(1);\n\n          if (freeze) {\n            args.forEach(deepFreeze);\n          }\n\n          if (itemMaxAge) {\n            cache.set(key, result, itemMaxAge.apply(self, parameters.concat(result)));\n          } else {\n            cache.set(key, result);\n          }\n        } //immediately call every other callback waiting\n\n\n        const waiting = loading.get(key).concat(callback);\n        loading.delete(key);\n        waiting.forEach(function (callback) {\n          if (clone) {\n            return callback.apply(null, args.map(_.cloneDeep));\n          }\n\n          callback.apply(null, args);\n        }); /////////\n      }));\n    } else {\n      loading.get(key).push(callback);\n    }\n  };\n\n  result.keys = cache.keys.bind(cache);\n\n  _.extend(result, {\n    del\n  }, options);\n\n  return result;\n};\n\nmodule.exports.sync = function (options) {\n  const cache = new LRU(_.pick(options, lru_params));\n  const load = options.load;\n  const hash = options.hash;\n  const disable = options.disable;\n  const bypass = options.bypass;\n  const self = this;\n  const itemMaxAge = options.itemMaxAge;\n\n  if (disable) {\n    return load;\n  }\n\n  const result = function () {\n    var args = _.toArray(arguments);\n\n    if (bypass && bypass.apply(self, arguments)) {\n      return load.apply(self, arguments);\n    }\n\n    var key = hash.apply(self, args);\n    var fromCache = cache.get(key);\n\n    if (fromCache) {\n      return fromCache;\n    }\n\n    const result = load.apply(self, args);\n\n    if (itemMaxAge) {\n      cache.set(key, result, itemMaxAge.apply(self, args.concat([result])));\n    } else {\n      cache.set(key, result);\n    }\n\n    return result;\n  };\n\n  result.keys = cache.keys.bind(cache);\n  return result;\n};","map":null,"metadata":{},"sourceType":"script"}